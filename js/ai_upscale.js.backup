class AIUpscaler {



    constructor() {



        this.upscaler = null;



        this.isModelLoaded = false;



        this.currentScale = 4;



        this.currentModel = 'esrgan-medium';



        this.fileList = [];



        this.isProcessing = false;



        this.isModelLoading = false;



        this.modelLoadingPromise = null;



        this.currentComparisonFile = null;










        



        this.init();



    }



    



    async init() {



        this.uploadArea = document.getElementById('uploadArea');



        this.fileInput = document.getElementById('fileInput');



        this.scaleSelect = document.getElementById('scaleSelect');



        this.modelSelect = document.getElementById('modelSelect');



        this.modelLabel = document.getElementById('modelLabel');
        this.modelStatus = document.getElementById('modelStatus');









        this.processBtn = document.getElementById('processBtn');



        this.clearBtn = document.getElementById('clearBtn');



        this.downloadAllBtn = document.getElementById('downloadAllBtn');



        this.fileListContainer = document.getElementById('fileList');



        this.progressContainer = document.getElementById('progressContainer');



        this.progressFill = document.getElementById('progressFill');



        this.progressText = document.getElementById('progressText');



        



        this.browserModels = [
            { value: 'esrgan-medium', label: 'ESRGAN Medium（推荐）' },
            { value: 'esrgan-slim', label: 'ESRGAN Slim（更快）' }
        ];




        



        this.currentModel = this.populateModelSelect(this.browserModels, this.currentModel);










        this.bindEvents();



        this.initComparisonSlider();






        this.updateButtons();
        this.loadModel();




    }



    



    populateModelSelect(models, selectedValue) {



        if (!this.modelSelect || !Array.isArray(models) || models.length === 0) {



            return selectedValue;



        }







        this.modelSelect.innerHTML = models



            .map((model) => `<option value="${model.value}">${model.label}</option>`)



            .join('');







        const finalValue = models.some((model) => model.value === selectedValue)



            ? selectedValue



            : models[0].value;



        this.modelSelect.value = finalValue;



        return finalValue;



    }








    setModelStatus(text, state) {
        if (!this.modelStatus) return;
        this.modelStatus.textContent = text;
        this.modelStatus.classList.remove("ok", "warn", "error");
        if (state) {
            this.modelStatus.classList.add(state);
        }
    }

    markModelStale() {
        this.isModelLoaded = false;
        this.upscaler = null;
        this.setModelStatus('?????', 'warn');
        this.updateButtons();
    }
    async loadModel() {
        if (this.isModelLoading && this.modelLoadingPromise) {
            return this.modelLoadingPromise;
        }
        if (this.isModelLoaded) return true;

        this.isModelLoading = true;
        this.isModelLoaded = false;
        this.setModelStatus('?????...', 'warn');
        this.updateButtons();

        this.modelLoadingPromise = (async () => {
            try {
                this.upscaler = new Upscaler({
                    model: this.getModel()
                });

                await this.upscaler.getModel();

                this.isModelLoaded = true;
                this.setModelStatus('?????', 'ok');
                return true;
            } catch (error) {
                console.error('Model loading failed:', error);
                this.setModelStatus('??????????', 'error');
                alert('??????: ' + error.message);
                return false;
            } finally {
                this.isModelLoading = false;
                this.modelLoadingPromise = null;
                this.updateButtons();
            }
        })();

        return this.modelLoadingPromise;
    }
    getModel() {



        const scale = `x${this.currentScale}`;







        const models = {



            'esrgan-medium': window.ESRGANMedium,



            'esrgan-slim': window.ESRGANSlim



        };







        let modelPackage = models[this.currentModel];



        if (!modelPackage || typeof modelPackage !== 'object') {



            const fallbackOrder = ['esrgan-medium', 'esrgan-slim'];



            for (const key of fallbackOrder) {



                if (models[key] && typeof models[key] === 'object') {



                    this.currentModel = key;



                    if (this.modelSelect) {



                        this.modelSelect.value = key;



                    }



                    modelPackage = models[key];



                    break;



                }



            }



        }







        if (!modelPackage || typeof modelPackage !== 'object') {



            console.error('Available models:', Object.keys(models).filter(key => models[key]));



            throw new Error(`Model ${this.currentModel} not found`);



        }







        if (!modelPackage[scale]) {



            throw new Error(`${this.currentModel} does not support ${scale} scale`);



        }







        return modelPackage[scale];



    }







    getUpscaleOptions() {



        if (this.currentModel === 'esrgan-slim') {



            return { patchSize: 64, padding: 2 };



        }



        



        return { patchSize: 128, padding: 8 };



    }



    



    initComparisonSlider() {



        const comparisonSlider = document.getElementById('comparisonSlider');



        const comparisonHandle = document.getElementById('comparisonHandle');



        const comparisonAfter = document.querySelector('.comparison-after');



        



        let isDragging = false;



        



        const updateSlider = (e) => {



            const rect = comparisonSlider.getBoundingClientRect();



            const x = (e.clientX || e.touches[0].clientX) - rect.left;



            const percent = Math.max(0, Math.min(100, (x / rect.width) * 100));



            



            comparisonHandle.style.left = percent + '%';



            comparisonAfter.style.clipPath = `inset(0 0 0 ${percent}%)`;



        };



        



        const startDrag = (e) => {



            isDragging = true;



            updateSlider(e);



        };



        



        const stopDrag = () => {



            isDragging = false;



        };



        



        const onDrag = (e) => {



            if (!isDragging) return;



            e.preventDefault();



            updateSlider(e);



        };



        



        comparisonHandle.addEventListener('mousedown', startDrag);



        comparisonHandle.addEventListener('touchstart', startDrag);



        



        document.addEventListener('mouseup', stopDrag);



        document.addEventListener('touchend', stopDrag);



        



        document.addEventListener('mousemove', onDrag);



        document.addEventListener('touchmove', onDrag);



        



        comparisonSlider.addEventListener('click', (e) => {



            if (e.target === comparisonHandle || comparisonHandle.contains(e.target)) return;



            updateSlider(e);



        });



        



        document.getElementById('closeModal').addEventListener('click', () => {



            document.getElementById('comparisonModal').style.display = 'none';



        });



        



        document.getElementById('comparisonModal').addEventListener('click', (e) => {



            if (e.target.id === 'comparisonModal') {



                document.getElementById('comparisonModal').style.display = 'none';



            }



        });



        



        document.getElementById('prevBtn').addEventListener('click', () => {



            this.showPreviousComparison();



        });



        



        document.getElementById('nextBtn').addEventListener('click', () => {



            this.showNextComparison();



        });



        



        document.addEventListener('keydown', (e) => {



            const modal = document.getElementById('comparisonModal');



            if (modal.style.display === 'flex') {



                if (e.key === 'ArrowLeft') {



                    this.showPreviousComparison();



                } else if (e.key === 'ArrowRight') {



                    this.showNextComparison();



                } else if (e.key === 'Escape') {



                    modal.style.display = 'none';



                }



            }



        });



    }



    



    bindEvents() {
        this.uploadArea.addEventListener('click', () => {
            this.fileInput.click();
        });

        this.fileInput.addEventListener('change', (e) => {
            const files = Array.from(e.target.files);
            this.handleFiles(files);
            e.target.value = '';
        });

        this.uploadArea.addEventListener('dragover', (e) => {
            e.preventDefault();
            this.uploadArea.classList.add('drag-over');
        });

        this.uploadArea.addEventListener('dragleave', () => {
            this.uploadArea.classList.remove('drag-over');
        });

        this.uploadArea.addEventListener('drop', (e) => {
            e.preventDefault();
            this.uploadArea.classList.remove('drag-over');

            const files = Array.from(e.dataTransfer.files).filter(file =>
                file.type.startsWith('image/')
            );
            this.handleFiles(files);
        });

        this.scaleSelect.addEventListener('change', (e) => {
            this.currentScale = parseInt(e.target.value, 10);
            this.markModelStale();
        });

        this.modelSelect.addEventListener('change', (e) => {
            this.currentModel = e.target.value;
            this.markModelStale();
        });

        this.processBtn.addEventListener('click', () => {
            this.processAllFiles();
        });

        this.clearBtn.addEventListener('click', () => {
            this.clearAllFiles();
        });

        this.downloadAllBtn.addEventListener('click', () => {
            this.downloadAllFiles();
        });
    }
    handleFiles(files) {



        files.forEach(file => {



            if (!file.type.match('image.*')) {



                return;



            }







            const fileId = Date.now() + Math.random();



            const reader = new FileReader();







            reader.onload = (e) => {



                const img = new Image();



                img.onload = () => {



                    const fileData = {



                        id: fileId,



                        file: file,



                        name: file.name,



                        size: file.size,



                        originalImage: img,



                        upscaledImage: null,



                        status: 'pending',



                        preview: e.target.result



                    };







                    this.fileList.push(fileData);



                    this.renderFileItem(fileData);



                    this.updateButtons();



                };



                img.src = e.target.result;



            };







            reader.readAsDataURL(file);



        });



    }







    renderFileItem(fileData) {



        const fileItem = document.createElement('div');



        fileItem.className = 'file-item';



        fileItem.dataset.id = fileData.id;



        



        const sizeText = this.formatFileSize(fileData.size);



        



        fileItem.innerHTML = `



            <div class="file-info">



                <img src="${fileData.preview}" class="file-preview" alt="preview" style="cursor: default;">



                <div class="file-details">



                    <div class="file-name">${fileData.name}</div>



                    <div class="file-size">${sizeText} • ${fileData.originalImage.width} × ${fileData.originalImage.height} px</div>



                    <div class="file-result" style="display: none;"></div>



                </div>



            </div>



            <div class="file-actions">



                <span class="file-status"></span>



                <button class="file-preview-btn" disabled>对比</button>



                <button class="file-download" disabled>下载</button>



                <button class="file-remove">删除</button>



            </div>



        `;



        



        // 预览图点击事件 - 显示对比



        const previewImg = fileItem.querySelector('.file-preview');



        previewImg.addEventListener('click', () => {



            if (fileData.status === 'completed') {



                this.showComparison(fileData);



            }



        });



        



        const compareBtn = fileItem.querySelector('.file-preview-btn');



        compareBtn.addEventListener('click', () => {



            if (fileData.status === 'completed') {



                this.showComparison(fileData);



            }



        });



        



        // 下载按钮事件



        const downloadBtn = fileItem.querySelector('.file-download');



        downloadBtn.addEventListener('click', () => {



            this.downloadFile(fileData);



        });



        



        // 删除按钮事件



        const removeBtn = fileItem.querySelector('.file-remove');



        removeBtn.addEventListener('click', () => {



            this.removeFile(fileData.id);



        });



        



        this.fileListContainer.appendChild(fileItem);



    }



    



    updateFileItem(fileData) {



        const fileItem = this.fileListContainer.querySelector(`[data-id="${fileData.id}"]`);



        if (!fileItem) return;



        



        const statusSpan = fileItem.querySelector('.file-status');



        const downloadBtn = fileItem.querySelector('.file-download');



        const resultDiv = fileItem.querySelector('.file-result');



        const compareBtn = fileItem.querySelector('.file-preview-btn');



        const previewImg = fileItem.querySelector('.file-preview');



        



        switch (fileData.status) {



            case 'pending':



                statusSpan.textContent = '等待中';



                statusSpan.style.color = '#888';



                downloadBtn.disabled = true;



                compareBtn.disabled = true;



                resultDiv.style.display = 'none';



                if (previewImg) {



                    previewImg.style.cursor = 'default';



                    previewImg.classList.remove('is-ready');



                    previewImg.removeAttribute('title');



                }



                break;



                



            case 'processing':



                statusSpan.textContent = '处理中...';



                statusSpan.style.color = '#4a9d5f';



                downloadBtn.disabled = true;



                compareBtn.disabled = true;



                resultDiv.style.display = 'none';



                if (previewImg) {



                    previewImg.style.cursor = 'default';



                    previewImg.classList.remove('is-ready');



                    previewImg.removeAttribute('title');



                }



                break;



                



            case 'completed':



                statusSpan.textContent = '已完成';



                statusSpan.style.color = '#4a9d5f';



                downloadBtn.disabled = false;



                compareBtn.disabled = false;



                if (fileData.upscaledImage) {



                    resultDiv.textContent = `已放大至 ${fileData.upscaledImage.width} × ${fileData.upscaledImage.height} px`;



                    resultDiv.style.display = 'block';



                }



                if (previewImg) {



                    previewImg.style.cursor = 'pointer';



                    previewImg.title = '点击对比';



                    previewImg.classList.add('is-ready');



                }



                break;



                



            case 'error':



                statusSpan.textContent = '失败';



                statusSpan.style.color = '#d97f3e';



                downloadBtn.disabled = true;



                compareBtn.disabled = true;



                resultDiv.style.display = 'none';



                if (previewImg) {



                    previewImg.style.cursor = 'default';



                    previewImg.classList.remove('is-ready');



                    previewImg.removeAttribute('title');



                }



                break;



        }



    }



    



    async processAllFiles() {
        if (this.isProcessing) return;

        if (!this.isModelLoaded) {
            const ready = await this.loadModel();
            if (!ready) return;
        }

        let pendingFiles = this.fileList.filter(f => f.status === 'pending');
        if (pendingFiles.length === 0) {
            const completedFiles = this.fileList.filter(f => f.status === 'completed');
            if (completedFiles.length === 0) {
                alert('????????');
                return;
            }
            const shouldReprocess = confirm('???????????????????????????');
            if (!shouldReprocess) {
                return;
            }
            completedFiles.forEach((fileData) => {
                fileData.status = 'pending';
                this.updateFileItem(fileData);
            });
            pendingFiles = completedFiles;
        }

        this.isProcessing = true;
        this.processBtn.disabled = true;
        this.clearBtn.disabled = true;
        this.scaleSelect.disabled = true;
        this.modelSelect.disabled = true;
        this.progressContainer.style.display = 'block';

        let processed = 0;
        const total = pendingFiles.length;

        for (const fileData of pendingFiles) {
            fileData.status = 'processing';
            this.updateFileItem(fileData);

            await new Promise(resolve => setTimeout(resolve, 50));

            this.updateProgress(`??? ${processed + 1}/${total}: ${fileData.name}`, (processed / total) * 100);

            try {
                await this.processFile(fileData, processed, total);
                fileData.status = 'completed';
            } catch (error) {
                console.error(`File processing failed ${fileData.name}:`, error);
                fileData.status = 'error';
            }

            this.updateFileItem(fileData);
            processed++;

            await new Promise(resolve => setTimeout(resolve, 50));
            this.updateProgress(`??? ${processed}/${total}`, (processed / total) * 100);
        }

        this.isProcessing = false;
        this.processBtn.disabled = false;
        this.clearBtn.disabled = false;
        this.scaleSelect.disabled = false;
        this.modelSelect.disabled = false;
        this.hideProgress();

        const successCount = pendingFiles.filter(f => f.status === 'completed').length;
        const failCount = pendingFiles.filter(f => f.status === 'error').length;

        alert(`???????: ${successCount}???: ${failCount}`);

        if (successCount > 0) {
            const firstCompleted = this.fileList.find(f => f.status === 'completed');
            if (firstCompleted) {
                setTimeout(() => {
                    this.showComparison(firstCompleted);
                }, 500);
            }
        }

        this.updateButtons();
    }
    async processFile(fileData, currentIndex, total) {
        const tempCanvas = document.createElement('canvas');
        tempCanvas.width = fileData.originalImage.width;
        tempCanvas.height = fileData.originalImage.height;
        const tempCtx = tempCanvas.getContext('2d');
        tempCtx.drawImage(fileData.originalImage, 0, 0);

        const { patchSize, padding } = this.getUpscaleOptions();
        const upscaledSrc = await this.upscaler.upscale(tempCanvas, {
            output: 'base64',
            patchSize,
            padding,
            progress: (progress) => {
                const baseProgress = (currentIndex / total) * 100;
                const fileProgress = (progress / total) * 100;
                const totalProgress = baseProgress + fileProgress;
                this.updateProgress(
                    `处理中 ${currentIndex + 1}/${total}: ${fileData.name} - ${Math.round(progress * 100)}%`,
                    totalProgress
                );
            }
        });

        return new Promise((resolve, reject) => {
            const upscaledImg = new Image();
            upscaledImg.onload = () => {
                fileData.upscaledImage = upscaledImg;
                fileData.upscaledSrc = upscaledSrc;
                fileData.upscaledBlob = null;
                resolve();
            };
            upscaledImg.onerror = reject;
            upscaledImg.src = upscaledSrc;
        });
    }

    releaseFileResources(fileData) {



        if (!fileData) return;



        if (fileData.upscaledSrc && fileData.upscaledSrc.startsWith('blob:')) {



            URL.revokeObjectURL(fileData.upscaledSrc);



        }



    }



    



    downloadFile(fileData) {



        if (!fileData.upscaledImage || !fileData.upscaledSrc) return;



        



        const link = document.createElement('a');



        link.href = fileData.upscaledSrc;



        const nameWithoutExt = fileData.name.replace(/\.[^/.]+$/, '');



        link.download = `${nameWithoutExt}_upscaled_${this.currentScale}x.png`;



        document.body.appendChild(link);



        link.click();



        document.body.removeChild(link);



    }



    



    downloadAllFiles() {
        const completedFiles = this.fileList.filter(f => f.status === 'completed');

        if (completedFiles.length === 0) {
            alert('没有可下载的文件');
            return;
        }

        if (completedFiles.length === 1) {
            this.downloadFile(completedFiles[0]);
            return;
        }

        let delay = 0;
        completedFiles.forEach((fileData, index) => {
            setTimeout(() => {
                this.downloadFile(fileData);
            }, delay);
            delay += 300;
        });

        alert(`正在下载 ${completedFiles.length} 个文件，请留意浏览器下载提示`);
    }
    removeFile(fileId) {



        const target = this.fileList.find(f => f.id === fileId);



        if (target) {



            this.releaseFileResources(target);



        }



        this.fileList = this.fileList.filter(f => f.id !== fileId);



        const fileItem = this.fileListContainer.querySelector(`[data-id="${fileId}"]`);



        if (fileItem) {



            fileItem.remove();



        }



        this.updateButtons();



    }



    



    clearAllFiles() {
        if (this.isProcessing) return;

        if (this.fileList.length > 0 && !confirm('确定要清空所有文件吗？')) {
            return;
        }

        this.fileList.forEach((fileData) => this.releaseFileResources(fileData));
        this.fileList = [];
        this.fileListContainer.innerHTML = '';
        this.updateButtons();
    }
    updateButtons() {
        const hasPendingFiles = this.fileList.some(f => f.status === 'pending');
        const hasCompletedFiles = this.fileList.some(f => f.status === 'completed');

        const canProcess = (hasPendingFiles || hasCompletedFiles) && !this.isProcessing && !this.isModelLoading;
        this.processBtn.disabled = !canProcess;
        if (!hasPendingFiles && hasCompletedFiles) {
            this.processBtn.textContent = '????';
        } else {
            this.processBtn.textContent = '????';
        }
        this.clearBtn.disabled = this.fileList.length === 0 || this.isProcessing;

        if (hasCompletedFiles) {
            this.downloadAllBtn.style.display = 'inline-block';
        } else {
            this.downloadAllBtn.style.display = 'none';
        }
    }
    updateProgress(text, percent) {



        this.progressText.textContent = text;



        this.progressFill.style.width = percent + '%';



    }



    



    hideProgress() {



        this.progressContainer.style.display = 'none';



        this.progressFill.style.width = '0%';



    }



    



    formatFileSize(bytes) {



        if (bytes < 1024) return bytes + ' B';



        if (bytes < 1024 * 1024) return (bytes / 1024).toFixed(2) + ' KB';



        return (bytes / (1024 * 1024)).toFixed(2) + ' MB';



    }



    



    showComparison(fileData) {



        if (!fileData.upscaledImage) return;



        



        this.currentComparisonFile = fileData;



        const modal = document.getElementById('comparisonModal');



        const originalCanvas = document.getElementById('originalCanvas');



        const upscaledCanvas = document.getElementById('upscaledCanvas');



        const originalInfo = document.getElementById('originalInfo');



        const upscaledInfo = document.getElementById('upscaledInfo');



        const comparisonSlider = document.getElementById('comparisonSlider');



        const currentFileName = document.getElementById('currentFileName');



        



        const completedFiles = this.fileList.filter(f => f.status === 'completed');



        const currentIndex = completedFiles.indexOf(fileData);



        currentFileName.textContent = `${fileData.name} (${currentIndex + 1}/${completedFiles.length})`;



        



        document.getElementById('prevBtn').disabled = currentIndex === 0;



        document.getElementById('nextBtn').disabled = currentIndex === completedFiles.length - 1;



        



        const maxWidth = Math.min(1200, window.innerWidth * 0.85);



        const maxHeight = window.innerHeight * 0.7;



        let width = fileData.upscaledImage.width;



        let height = fileData.upscaledImage.height;



        



        if (width > maxWidth || height > maxHeight) {



            const ratio = Math.min(maxWidth / width, maxHeight / height);



            width = width * ratio;



            height = height * ratio;



        }



        



        comparisonSlider.style.width = width + 'px';



        comparisonSlider.style.maxWidth = '100%';



        comparisonSlider.style.height = height + 'px';



        



        originalCanvas.width = width;



        originalCanvas.height = height;



        const originalCtx = originalCanvas.getContext('2d');



        originalCtx.drawImage(fileData.originalImage, 0, 0, width, height);



        



        upscaledCanvas.width = width;



        upscaledCanvas.height = height;



        const upscaledCtx = upscaledCanvas.getContext('2d');



        upscaledCtx.drawImage(fileData.upscaledImage, 0, 0, width, height);



        



        originalInfo.textContent = `原图：${fileData.originalImage.width} × ${fileData.originalImage.height} px`;



        upscaledInfo.textContent = `放大后：${fileData.upscaledImage.width} × ${fileData.upscaledImage.height} px`;



        



        document.getElementById('comparisonHandle').style.left = '50%';



        document.querySelector('.comparison-after').style.clipPath = 'inset(0 0 0 50%)';



        



        modal.style.display = 'flex';



    }



    



    showPreviousComparison() {



        const completedFiles = this.fileList.filter(f => f.status === 'completed');



        const currentIndex = completedFiles.indexOf(this.currentComparisonFile);



        if (currentIndex > 0) {



            this.showComparison(completedFiles[currentIndex - 1]);



        }



    }



    



    showNextComparison() {



        const completedFiles = this.fileList.filter(f => f.status === 'completed');



        const currentIndex = completedFiles.indexOf(this.currentComparisonFile);



        if (currentIndex < completedFiles.length - 1) {



            this.showComparison(completedFiles[currentIndex + 1]);



        }



    }



}







document.addEventListener('DOMContentLoaded', () => {



    new AIUpscaler();



});